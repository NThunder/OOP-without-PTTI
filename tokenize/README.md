
### Tokenize

Первым шагом практически в любой задаче, работающей с 
пользовательским вводом, является *токенизация* - разбиение исходного.
текста на отдельные смысловые части (например, фразы, слова, буквы).
В нашей задаче в качестве токенов будут выступать математические символы.

Всего рассмотрим 13 типов токенов: "+" (`PlusToken`),
"-" (`MinusToken`), "*" (`MultiplyToken`), "/" (`DivideToken`),
"%" (`ResidualToken`), "(" (`OpeningBracketToken`), 
")" (`ClosingBracketToken`), "sqr" (`SquareToken`),
"max" (`MaxToken`), "min" (`MinToken`), "abs" (`AbsToken`),
 "23" (`NumberToken`, здесь произвольное число),
"abracadabra" (`UnknownToken`)

Для каждого типа токена необходимо заведена своя структура. Все структуры пустые, за исключением
`NumberToken`, который дополнительно в `int` поле `value`
хранит значение числа, и `UnknownToken`, который в строковом поле
`value` хранит значение неизвестного токена.

Чтобы хранить все токены в одном контейнере,
все значения приводятся к одному типу с помощью класса `std::variant` (C++17), который
может хранить в себе значение одного из заранее заданных типов
(ООП аналог `union`).

#### std::variant (C++17)

https://en.cppreference.com/w/cpp/utility/variant

`std::variant` - шаблонный класс, который принимает произвольное
количество параметров-типов шаблона и может хранить в себе
произвольное значение которое принадлежит одному из указанных типов.
Основные функции:
* `std::get<T>` принимает тип `T` в качестве параметра шаблона и объект `std::variant` в
качестве аргумента, если хранимый в данный момент тип совпадает
с указанным, то возвращается значение, иначе бросается исключение
`std::bad_variant_access`; 
* `std::holds_alternative<T>` проверяет лежит ли в данный момент в объекте значение типа `T` и возвращает `true` или `false` в зависимости от результата;
* `operator==` возвращает `true`, если совпадают хранимые в данный момент типы и
их значения.

#### Детали реализации

В файле `tokenize.h` объявлены и определины описанные выше структуры
и заведён тип `Token`, который может хранить любой тип токена, как
псевдоним `std::variant<PlusToken, MinusToken,... (и т.д.)>` (
с помощью `using`).

Написана функция `std::vector<Token> Tokenize(const std::string&)`,
 которая принимает строку и возвращает последовательность токенов в ней.
 
 Прототип описан в файле `tokenize.h`, а реализация и необходимые 
 побочные функции в `tokenize.cpp`.
 
 Для простоты считаем, что все токены разделены пробелами (произвольным их количеством).
 
