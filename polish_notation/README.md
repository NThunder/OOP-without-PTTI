
### Polish Notation

Трудоемкость написания калькулятора заключается в сложности определения
порядка выполняемых действий и построения дерева разбора выражения.

Выражения записанные в польской нотации
гораздо проще для разбора так как операции в ней уже записаны в нужном
для вычисления порядке.

Формально, каждое значение (токен) в выражении можно считать некоторой операцией
над стеком (вершина стека слева). Вычисление операции в общем случае выглядит так:
1) она извлекается из стека
2) рекурсивно вычисляются и сохраняются необходимые операнды
3) вычисляется значение операции
4) результат помещается в стек (в виде константы)

Например, константа - это операция не требующая операндов, поэтому
она извлекается и сразу же помещается обратно (она сама и есть результат).

Возведение в квадрат - унарная операция: она извлекается; далее вычисляется
операнд посредством вычисления следующей операции в стеке; мы знаем, что
результат вычисления теперь находится на вершине и это константа;
извлекаем ее, возводим в квадрат; результат помещаем в стек.

Сумма - бинарная операция: она извлекается; вычисляем первый операнд как
операцию на вершине стека; результат на вершине - извлекаем и сохраняем; 
аналогично вычисляем второй операнд; суммируем два операнда; результат
помещаем на вершину стека.

Видно, что вычисление выражения сводится к вычислению первой операции
в стеке (все остальное вычисляется рекурсивно). В случае, если
выражение было составлено верно, то в результате рекурсивных вызовов
в стеке останется только одна операция - константа, в которой
будет записан ответ.

#### Детали реализации

Решение состоит из двух частей - токенизация и вычисление выражения.

В файле `operation.h` объявлены классы операций, а в 
`operation.cpp` написана реализация их методов. (Всюду ниже используется
сокращение `Stack = std::stack<std::unique_ptr<IOperation>>`)

* `IOperation` - абстрактный класс для представления произвольной операции.
    * Содержит единственный чисто виртуальный метод `void Calculate(Stack*)`,
который вычисляет требуемое количество операндов и добавляет результат в стек (который принимается по указателю).
* `Constant` - наследник `IOperation`.
    * Имеет конструктор от `int`.
    * Метод `int Value()`, возвращающий свое значение
    * метод `Calculate`
* `IUnaryOperation` - абстрактный класс, наследник `IOperation`, представляющий произвольную унарную операцию
    * Содержит метод `int GetOperand(Stack*)`, который вычисляет свой операнд по данному стеку
    * Чисто виртуальный метод `int PerformOperation(int)`, который принимает операнд и вычисляет результат операции
    * Определяет метод `Calculate`, путем вычисления операнда и применения к нему операции
* `IBinaryOperation` - абстрактный класс, наследник `IOperation`, представляющий произвольную бинарную операцию
     * Содержит метод `std::pair<int, int> GetOperands(Stack*)`, который вычисляет свои операнды по данному стеку
     * Чисто виртуальный метод `int PerformOperation(int, int)`, который принимает операнды и вычисляет результат операции
     * Определяет метод `Calculate`, путем вычисления операндов и применения к ним операции
     
Программа поддерживает следующие операции: `Sum` (+), `Subtract` (-),
`Multiply`(*), `Divide`(/), `Residual`(%), `Minimum`(min), `Maximum`(max),
`AbsoluteValue`(abs), `Square`(sqr). Каждая операция унаследована
от нужного класса и реализован соответствующий метод `PerformOperation`.

Также реализована функция `int ParsePolishNotation(const std::string& input)`,
которая токенизирует вход, формирует стек и запускает вычисления. Прототип
и реализация описана в `polish_notation.h` и `polish_notation.cpp`

Программа бросает исключения `UnknownSymbolError`, если
в результате токенизации был получен неизвестный токен; `WrongOperandsNumberError`,
если число операндов у операции меньше требуемого; `WrongExpressionError`,
если в результате вычисления выражения в стеке осталось более одного числа (некорректное выражение).

Замечание:

В задаче вместо механизмов виртуального наследования и абстрактных классов реализован их упращённый аналог.
 
 
 
 **Замечания.**
В задаче реализован упрощенный аналог механизма виртуального наследования и абстрактных классов.

